var searchIndex={};
searchIndex["extended_collections"] = {"doc":"extended-collections-rs","i":[[0,"arena","extended_collections","Fast, but limited allocator.",null,null],[3,"Entry","extended_collections::arena","A struct representing an entry to `TypedArena<T>`",null,null],[3,"TypedArena","","A fast, but limited allocator that only allocates a single…",null,null],[11,"new","","Constructs a new, empty `TypedArena<T>` with a specific…",0,[[["usize"]],["self"]]],[11,"allocate","","Allocates an object in the typed arena and returns an…",0,[[["self"],["t"]],["entry"]]],[11,"free","","Deallocates an object in the typed arena and returns the…",0,[[["self"],["entry"]],["t"]]],[11,"get","","Returns an immutable reference to an object in the typed…",0,[[["self"],["entry"]],[["t"],["option"]]]],[11,"get_mut","","Returns a mutable reference to an object in the typed…",0,[[["self"],["entry"]],[["option"],["t"]]]],[0,"avl_tree","extended_collections","Self-balancing binary search tree where the heights of the…",null,null],[3,"AvlMap","extended_collections::avl_tree","An ordered map implemented using an avl tree.",null,null],[3,"AvlSet","","An ordered set implemented using a avl_tree.",null,null],[11,"new","","Constructs a new, empty `AvlMap<T, U>`.",1,[[],["self"]]],[11,"insert","","Inserts a key-value pair into the map. If the key already…",1,[[["u"],["self"],["t"]],["option"]]],[11,"remove","","Removes a key-value pair from the map. If the key exists…",1,[[["self"],["v"]],["option"]]],[11,"contains_key","","Checks if a key exists in the map.",1,[[["v"],["self"]],["bool"]]],[11,"get","","Returns an immutable reference to the value associated…",1,[[["v"],["self"]],[["u"],["option"]]]],[11,"get_mut","","Returns a mutable reference to the value associated with a…",1,[[["self"],["v"]],[["option"],["u"]]]],[11,"len","","Returns the number of elements in the map.",1,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the map is empty.",1,[[["self"]],["bool"]]],[11,"clear","","Clears the map, removing all values.",1,[[["self"]]]],[11,"floor","","Returns a key in the map that is less than or equal to a…",1,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the map that is greater than or equal to…",1,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the map. Returns `None` if the…",1,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the map. Returns `None` if the…",1,[[["self"]],[["t"],["option"]]]],[11,"iter","","Returns an iterator over the map. The iterator will yield…",1,[[["self"]],["avlmapiter"]]],[11,"iter_mut","","Returns a mutable iterator over the map. The iterator will…",1,[[["self"]],["avlmapitermut"]]],[11,"new","","Constructs a new, empty `AvlSet<T>`",2,[[],["self"]]],[11,"insert","","Inserts a key into the set. If the key already exists in…",2,[[["self"],["t"]],["option"]]],[11,"remove","","Removes a key from the set. If the key exists in the set,…",2,[[["self"],["t"]],["option"]]],[11,"contains","","Checks if a key exists in the set.",2,[[["v"],["self"]],["bool"]]],[11,"len","","Returns the number of elements in the set.",2,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the set is empty.",2,[[["self"]],["bool"]]],[11,"clear","","Clears the set, removing all values.",2,[[["self"]]]],[11,"floor","","Returns a key in the set that is less than or equal to a…",2,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the set that is greater than or equal to…",2,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the set. Returns `None` if the…",2,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the set. Returns `None` if the…",2,[[["self"]],[["t"],["option"]]]],[11,"iter","","Returns an iterator over the set. The iterator will yield…",2,[[["self"]],["avlsetiter"]]],[0,"bp_tree","extended_collections","Disk-resident N-ary tree.",null,null],[3,"BpMap","extended_collections::bp_tree","An ordered map implemented using an on-disk B+ tree.",null,null],[4,"Error","","Convenience `Error` enum for `bp_tree`.",null,null],[13,"IOError","","An input or output error.",3,null],[13,"SerdeError","","A serialization or deserialization error.",3,null],[11,"new","","Constructs a new, empty `BpMap<T, U>` with maximum sizes…",4,[[["u64"],["p"]],[["result",["bpmap"]],["bpmap"]]]],[11,"with_degrees","","Constructs a new, empty `BpMap<T, U>` with maximum sizes…",4,[[["usize"],["p"],["u64"]],[["result",["bpmap"]],["bpmap"]]]],[11,"open","","Opens an existing `BpMap<T, U>` from a file.",4,[[["p"]],[["result",["bpmap"]],["bpmap"]]]],[11,"insert","","Inserts a key-value pair into the map. If the key already…",4,[[["u"],["self"],["t"]],[["option"],["result",["option"]]]]],[11,"remove","","Removes a key-value pair from the map. If the key exists…",4,[[["self"],["v"]],[["option"],["result",["option"]]]]],[11,"contains_key","","Checks if a key exists in the map.",4,[[["self"],["v"]],[["result",["bool"]],["bool"]]]],[11,"get","","Returns the value associated with a particular key. It…",4,[[["self"],["v"]],[["result",["option"]],["option"]]]],[11,"len","","Returns the number of elements in the map.",4,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the map is empty.",4,[[["self"]],["bool"]]],[11,"clear","","Clears the map, removing all values.",4,[[["self"]],["result"]]],[11,"min","","Returns the minimum key of the map. Returns `None` if the…",4,[[["self"]],[["option"],["result",["option"]]]]],[11,"max","","Returns the maximum key of the map. Returns `None` if the…",4,[[["self"]],[["option"],["result",["option"]]]]],[11,"iter_mut","","Returns a mutable iterator over the map. The iterator will…",4,[[["self"]],[["bpmapitermut"],["result",["bpmapitermut"]]]]],[6,"Result","","Convenience `Result` type for `bp_tree`.",null,null],[0,"lsm_tree","extended_collections","Hybrid tree comprised of disk-resident sorted runs of data…",null,null],[3,"LsmMap","extended_collections::lsm_tree","An ordered map implemented using a log structured…",null,null],[4,"Error","","Convenience `Error` enum for `lsm_tree`.",null,null],[13,"IOError","","An input or output error.",5,null],[13,"SerdeError","","A serialization or deserialization error.",5,null],[0,"compaction","","Strategies for merging disk-resident sorted runs of data.",null,null],[3,"LeveledStrategy","extended_collections::lsm_tree::compaction","A compaction strategy based on grouping SSTables into…",null,null],[3,"SizeTieredStrategy","","A compaction strategy based on bucketing SSTables by their…",null,null],[11,"new","","Constructs a new `LeveledStrategy<T, U>` with specific…",6,[[["usize"],["p"],["u64"]],["result"]]],[11,"open","","Opens an existing `LeveledStrategy<T, U>` from a folder.",6,[[["p"]],["result"]]],[11,"new","","Constructs a new `SizeTieredStrategy<T, U>` with specific…",7,[[["usize"],["p"],["f64"],["u64"]],["result"]]],[11,"open","","Opens an existing `SizeTieredStrategy<T, U>` from a folder.",7,[[["p"]],["result"]]],[6,"CompactionIter","","An iterator for the disk-resident data.",null,null],[8,"CompactionStrategy","","Trait for types that have compaction logic for…",null,null],[10,"get_path","","Returns the path of the disk-resident data.",8,[[["self"]],["path"]]],[10,"get_max_in_memory_size","","Returns the maximum size of the in-memory tree in bytes.",8,[[["self"]],["u64"]]],[10,"get_and_increment_logical_time","","Returns and increments the current logical time of the…",8,[[["self"]],[["u64"],["result",["u64"]]]]],[10,"try_compact","","Adds a SSTable to the compaction strategy and compacts the…",8,[[["self"],["sstable"]],["result"]]],[10,"flush","","Waits until the current compaction thread, if any,…",8,[[["self"]],["result"]]],[10,"get","","Searches through disk-resident data and returns the value…",8,[[["self"],["v"]],[["option",["sstablevalue"]],["result",["option"]]]]],[10,"len_hint","","Returns the approximate number of items in the…",8,[[["self"]],[["usize"],["result",["usize"]]]]],[10,"len","","Returns the number of items in the disk-resident data.",8,[[["self"]],[["usize"],["result",["usize"]]]]],[10,"is_empty","","Returns `true` if the disk-resident data is empty.",8,[[["self"]],[["result",["bool"]],["bool"]]]],[10,"clear","","Clears the disk-resident data, removing all values.",8,[[["self"]],["result"]]],[10,"min","","Returns the minimum key of the disk-resident data. Returns…",8,[[["self"]],[["result",["option"]],["option"]]]],[10,"max","","Returns the maximum key of the disk-resident data. Returns…",8,[[["self"]],[["result",["option"]],["option"]]]],[10,"iter","","Returns an iterator over the disk-resident data. The…",8,[[["self"]],[["result",["box"]],["box",["compactioniter"]]]]],[11,"new","extended_collections::lsm_tree","Constructs a new `LsmMap<T, U>` with a specific…",9,[[["c"]],["self"]]],[11,"insert","","Inserts a key-value pair into the map. If the key-value…",9,[[["u"],["self"],["t"]],["result"]]],[11,"remove","","Removes a key-value pair into the map by inserting a…",9,[[["self"],["t"]],["result"]]],[11,"contains_key","","Checks if a key exists in the map.",9,[[["self"],["v"]],[["result",["bool"]],["bool"]]]],[11,"get","","Returns the value associated with a particular key. It…",9,[[["self"],["v"]],[["option"],["result",["option"]]]]],[11,"len_hint","","Returns the approximate number of elements in the map. The…",9,[[["self"]],[["usize"],["result",["usize"]]]]],[11,"len","","Returns the number of elements in the map by first…",9,[[["self"]],[["usize"],["result",["usize"]]]]],[11,"is_empty","","Returns `true` if the map is empty. The in-memory tree is…",9,[[["self"]],[["result",["bool"]],["bool"]]]],[11,"clear","","Clears the map, removing all values. This function will…",9,[[["self"]],["result"]]],[11,"min","","Returns the minimum key of the map. Returns `None` if the…",9,[[["self"]],[["result",["option"]],["option"]]]],[11,"max","","Returns the maximum key of the map. Returns `None` if the…",9,[[["self"]],[["result",["option"]],["option"]]]],[11,"flush","","Flushes the in-memory tree into a SSTable if it is not…",9,[[["self"]],["result"]]],[11,"iter","","Returns an iterator over the map. The iterator will yield…",9,[[["self"]],[["result",["box"]],["box",["compactioniter"]]]]],[6,"Result","","Convenience `Result` type for `lsm_tree`.",null,null],[0,"radix","extended_collections","Space-optimized trie.",null,null],[3,"RadixMap","extended_collections::radix","An ordered map implemented using a radix tree.",null,null],[3,"RadixSet","","An ordered set implemented using a radix tree.",null,null],[11,"new","","Constructs a new, empty `RadixMap<T>`.",10,[[],["self"]]],[11,"insert","","Inserts a key-value pair into the map. If the key already…",10,[[["self"],["t"]],["option"]]],[11,"remove","","Removes a key-value pair from the map. If the key exists…",10,[[["self"]],["option"]]],[11,"contains_key","","Checks if a key exists in the map.",10,[[["self"]],["bool"]]],[11,"get","","Returns an immutable reference to the value associated…",10,[[["self"]],[["t"],["option"]]]],[11,"get_mut","","Returns a mutable reference to the value associated with a…",10,[[["self"]],[["option"],["t"]]]],[11,"len","","Returns the number of elements in the map.",10,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the map is empty.",10,[[["self"]],["bool"]]],[11,"clear","","Clears the map, removing all values.",10,[[["self"]]]],[11,"get_longest_prefix","","Returns all keys that share the longest common prefix with…",10,[[["self"]],[["vec",["vec"]],["vec",["u8"]]]]],[11,"min","","Returns the minimum lexographic key of the map. Returns…",10,[[["self"]],[["vec",["u8"]],["option",["vec"]]]]],[11,"max","","Returns the maximum lexographic key of the map. Returns…",10,[[["self"]],[["vec",["u8"]],["option",["vec"]]]]],[11,"iter","","Returns an iterator over the map. The iterator will yield…",10,[[["self"]],["radixmapiter"]]],[11,"iter_mut","","Returns a mutable iterator over the map. The iterator will…",10,[[["self"]],["radixmapitermut"]]],[11,"new","","Constructs a new, empty `RadixSet`.",11,[[],["self"]]],[11,"insert","","Inserts a key into the set. If the key already exists in…",11,[[["self"]],[["vec",["u8"]],["option",["vec"]]]]],[11,"remove","","Removes a key from the set. If the key exists in the set,…",11,[[["self"]],[["vec",["u8"]],["option",["vec"]]]]],[11,"contains","","Checks if a key exists in the set.",11,[[["self"]],["bool"]]],[11,"len","","Returns the number of elements in the set.",11,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the set is empty.",11,[[["self"]],["bool"]]],[11,"clear","","Clears the set, removing all values.",11,[[["self"]]]],[11,"get_longest_prefix","","Returns all keys that share the longest common prefix with…",11,[[["self"]],[["vec",["vec"]],["vec",["u8"]]]]],[11,"min","","Returns the minimum lexographic key of the set. Returns…",11,[[["self"]],[["vec",["u8"]],["option",["vec"]]]]],[11,"max","","Returns the maximum lexographic key of the set. Returns…",11,[[["self"]],[["vec",["u8"]],["option",["vec"]]]]],[11,"iter","","Returns an iterator over the set. The iterator will yield…",11,[[["self"]],["radixsetiter"]]],[0,"red_black_tree","extended_collections","Self-balancing binary search tree that uses a color bit to…",null,null],[3,"RedBlackMap","extended_collections::red_black_tree","An ordered map implemented using an avl tree.",null,null],[3,"RedBlackSet","","An ordered set implemented using a red_black_tree.",null,null],[11,"new","","Constructs a new, empty `RedBlackMap<T, U>`.",12,[[],["self"]]],[11,"insert","","Inserts a key-value pair into the map. If the key already…",12,[[["u"],["self"],["t"]],["option"]]],[11,"remove","","Removes a key-value pair from the map. If the key exists…",12,[[["self"],["v"]],["option"]]],[11,"contains_key","","Checks if a key exists in the map.",12,[[["v"],["self"]],["bool"]]],[11,"get","","Returns an immutable reference to the value associated…",12,[[["v"],["self"]],[["u"],["option"]]]],[11,"get_mut","","Returns a mutable reference to the value associated with a…",12,[[["self"],["v"]],[["option"],["u"]]]],[11,"len","","Returns the number of elements in the map.",12,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the map is empty.",12,[[["self"]],["bool"]]],[11,"clear","","Clears the map, removing all values.",12,[[["self"]]]],[11,"floor","","Returns a key in the map that is less than or equal to a…",12,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the map that is greater than or equal to…",12,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the map. Returns `None` if the…",12,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the map. Returns `None` if the…",12,[[["self"]],[["t"],["option"]]]],[11,"iter","","Returns an iterator over the map. The iterator will yield…",12,[[["self"]],["redblackmapiter"]]],[11,"iter_mut","","Returns a mutable iterator over the map. The iterator will…",12,[[["self"]],["redblackmapitermut"]]],[11,"new","","Constructs a new, empty `RedBlackSet<T>`",13,[[],["self"]]],[11,"insert","","Inserts a key into the set. If the key already exists in…",13,[[["self"],["t"]],["option"]]],[11,"remove","","Removes a key from the set. If the key exists in the set,…",13,[[["self"],["t"]],["option"]]],[11,"contains","","Checks if a key exists in the set.",13,[[["v"],["self"]],["bool"]]],[11,"len","","Returns the number of elements in the set.",13,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the set is empty.",13,[[["self"]],["bool"]]],[11,"clear","","Clears the set, removing all values.",13,[[["self"]]]],[11,"floor","","Returns a key in the set that is less than or equal to a…",13,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the set that is greater than or equal to…",13,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the set. Returns `None` if the…",13,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the set. Returns `None` if the…",13,[[["self"]],[["t"],["option"]]]],[11,"iter","","Returns an iterator over the set. The iterator will yield…",13,[[["self"]],["redblacksetiter"]]],[0,"skiplist","extended_collections","Probabilistic linked hierarchy of subsequences.",null,null],[3,"SkipList","extended_collections::skiplist","A list implemented using a skiplist.",null,null],[3,"SkipMap","","An ordered map implemented using a skiplist.",null,null],[3,"SkipSet","","An ordered set implemented using a skiplist.",null,null],[11,"new","","Constructs a new, empty `SkipList<T>`.",14,[[],["self"]]],[11,"insert","","Inserts a value into the list at a particular index,…",14,[[["self"],["usize"],["t"]]]],[11,"remove","","Removes a value at a particular index from the list.…",14,[[["self"],["usize"]],["t"]]],[11,"push_front","","Inserts a value at the front of the list.",14,[[["self"],["t"]]]],[11,"push_back","","Inserts a value at the back of the list.",14,[[["self"],["t"]]]],[11,"pop_front","","Removes a value at the front of the list.",14,[[["self"]],["t"]]],[11,"pop_back","","Removes a value at the back of the list.",14,[[["self"]],["t"]]],[11,"get","","Returns a mutable reference to the value at a particular…",14,[[["self"],["usize"]],[["t"],["option"]]]],[11,"get_mut","","Returns a mutable reference to the value at a particular…",14,[[["self"],["usize"]],[["option"],["t"]]]],[11,"len","","Returns the number of elements in the list.",14,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the list is empty.",14,[[["self"]],["bool"]]],[11,"clear","","Clears the list, removing all values.",14,[[["self"]]]],[11,"iter","","Returns an iterator over the list.",14,[[["self"]],["skiplistiter"]]],[11,"iter_mut","","Returns a mutable iterator over the list.",14,[[["self"]],["skiplistitermut"]]],[11,"new","","Constructs a new, empty `SkipMap<T, U>`.",15,[[],["self"]]],[11,"insert","","Inserts a key-value pair into the map. If the key already…",15,[[["u"],["self"],["t"]],["option"]]],[11,"remove","","Removes a key-value pair from the map. If the key exists…",15,[[["self"],["v"]],["option"]]],[11,"contains_key","","Checks if a key exists in the map.",15,[[["v"],["self"]],["bool"]]],[11,"get","","Returns an immutable reference to the value associated…",15,[[["v"],["self"]],[["u"],["option"]]]],[11,"get_mut","","Returns a mutable reference to the value associated with a…",15,[[["self"],["v"]],[["option"],["u"]]]],[11,"len","","Returns the number of elements in the map.",15,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the map is empty.",15,[[["self"]],["bool"]]],[11,"clear","","Clears the map, removing all values.",15,[[["self"]]]],[11,"floor","","Returns a key in the map that is less than or equal to a…",15,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the map that is greater than or equal to…",15,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the map. Returns `None` if the…",15,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the map. Returns `None` if the…",15,[[["self"]],[["t"],["option"]]]],[11,"union","","Returns the union of two maps. If there is a key that is…",15,[[],["self"]]],[11,"intersection","","Returns the intersection of two maps. If there is a key…",15,[[],["self"]]],[11,"difference","","Returns the difference of `left` and `right`. The returned…",15,[[],["self"]]],[11,"symmetric_difference","","Returns the symmetric difference of `left` and `right`.…",15,[[],["self"]]],[11,"iter","","Returns an iterator over the map. The iterator will yield…",15,[[["self"]],["skipmapiter"]]],[11,"iter_mut","","Returns a mutable iterator over the map. The iterator will…",15,[[["self"]],["skipmapitermut"]]],[11,"new","","Constructs a new, empty `SkipSet<T>`.",16,[[],["self"]]],[11,"insert","","Inserts a key into the set. If the key already exists in…",16,[[["self"],["t"]],["option"]]],[11,"remove","","Removes a key from the set. If the key exists in the set,…",16,[[["self"],["v"]],["option"]]],[11,"contains","","Checks if a key exists in the set.",16,[[["v"],["self"]],["bool"]]],[11,"len","","Returns the len of the set.",16,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the set is empty.",16,[[["self"]],["bool"]]],[11,"clear","","Clears the set, removing all values.",16,[[["self"]]]],[11,"floor","","Returns a key in the set that is less than or equal to a…",16,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the set that is greater than or equal to…",16,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the set. Returns `None` if the…",16,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the set. Returns `None` if the…",16,[[["self"]],[["t"],["option"]]]],[11,"union","","Returns the union of two set. The `+` operator is…",16,[[],["self"]]],[11,"intersection","","Returns the intersection of two sets.",16,[[],["self"]]],[11,"difference","","Returns the difference of `left` and `right`. The `-`…",16,[[],["self"]]],[11,"symmetric_difference","","Returns the symmetric difference of `left` and `right`.…",16,[[],["self"]]],[11,"iter","","Returns an iterator over the set. The iterator will yield…",16,[[["self"]],["skipsetiter"]]],[0,"splay_tree","extended_collections","Self-adjusting binary search tree with the additional…",null,null],[3,"SplayMap","extended_collections::splay_tree","An ordered map implemented using splay tree.",null,null],[3,"SplaySet","","An ordered map implemented using splay tree.",null,null],[11,"new","","Constructs a new, empty `SplayMap<T, U>`.",17,[[],["self"]]],[11,"insert","","Inserts a key-value pair into the map. If the key already…",17,[[["u"],["self"],["t"]],["option"]]],[11,"remove","","Removes a key-value pair from the map. If the key exists…",17,[[["self"],["v"]],["option"]]],[11,"contains_key","","Checks if a key exists in the map. Note that…",17,[[["v"],["self"]],["bool"]]],[11,"get","","Returns an immutable reference to the value associated…",17,[[["v"],["self"]],[["u"],["option"]]]],[11,"get_mut","","Returns a mutable reference to the value associated with a…",17,[[["self"],["v"]],[["option"],["u"]]]],[11,"len","","Returns the number of elements in the map.",17,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the map is empty.",17,[[["self"]],["bool"]]],[11,"clear","","Clears the map, removing all values.",17,[[["self"]]]],[11,"floor","","Returns a key in the map that is less than or equal to a…",17,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the map that is greater than or equal to…",17,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the map. Returns `None` if the…",17,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the map. Returns `None` if the…",17,[[["self"]],[["t"],["option"]]]],[11,"iter","","Returns an iterator over the map. The iterator will yield…",17,[[["self"]],["splaymapiter"]]],[11,"iter_mut","","Returns a mutable iterator over the map. The iterator will…",17,[[["self"]],["splaymapitermut"]]],[11,"new","","Constructs a new, empty `SplaySet<T>`",18,[[],["self"]]],[11,"insert","","Inserts a key into the set. If the key already exists in…",18,[[["self"],["t"]],["option"]]],[11,"remove","","Removes a key from the set. If the key exists in the set,…",18,[[["self"],["t"]],["option"]]],[11,"contains","","Checks if a key exists in the set.",18,[[["v"],["self"]],["bool"]]],[11,"len","","Returns the number of elements in the set.",18,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the set is empty.",18,[[["self"]],["bool"]]],[11,"clear","","Clears the set, removing all values.",18,[[["self"]]]],[11,"floor","","Returns a key in the set that is less than or equal to a…",18,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the set that is greater than or equal to…",18,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the set. Returns `None` if the…",18,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the set. Returns `None` if the…",18,[[["self"]],[["t"],["option"]]]],[11,"iter","","Returns an iterator over the set. The iterator will yield…",18,[[["self"]],["splaysetiter"]]],[0,"sync","extended_collections","Lock-free data structures.",null,null],[3,"Stack","extended_collections::sync","A concurrent and lock-free stack using Treiber's algorithm.",null,null],[11,"new","","Constructs a new, empty `Stack<T>`.",19,[[],["self"]]],[11,"push","","Pushes an item onto the stack.",19,[[["self"],["t"]]]],[11,"try_pop","","Attempts to pop the top element of the stack. Returns…",19,[[["self"]],["option"]]],[11,"len","","Returns the approximate number of elements in the stack.",19,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the approximate number of elements in…",19,[[["self"]],["bool"]]],[0,"treap","extended_collections","Probabilistic binary search tree where each node also…",null,null],[3,"TreapList","extended_collections::treap","A list implemented using an implicit treap.",null,null],[3,"TreapMap","","An ordered map implemented using a treap.",null,null],[3,"TreapSet","","An ordered set implemented using a treap.",null,null],[11,"new","","Constructs a new, empty `TreapList<T>`.",20,[[],["self"]]],[11,"insert","","Inserts a value into the list at a particular index,…",20,[[["self"],["usize"],["t"]]]],[11,"remove","","Removes a value at a particular index from the list.…",20,[[["self"],["usize"]],["t"]]],[11,"push_front","","Inserts a value at the front of the list.",20,[[["self"],["t"]]]],[11,"push_back","","Inserts a value at the back of the list.",20,[[["self"],["t"]]]],[11,"pop_front","","Removes a value at the front of the list.",20,[[["self"]],["t"]]],[11,"pop_back","","Removes a value at the back of the list.",20,[[["self"]],["t"]]],[11,"get","","Returns an immutable reference to the value at a…",20,[[["self"],["usize"]],[["t"],["option"]]]],[11,"get_mut","","Returns a mutable reference to the value at a particular…",20,[[["self"],["usize"]],[["option"],["t"]]]],[11,"len","","Returns the number of elements in the list.",20,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the list is empty.",20,[[["self"]],["bool"]]],[11,"clear","","Clears the list, removing all values.",20,[[["self"]]]],[11,"iter","","Returns an iterator over the list.",20,[[["self"]],["treaplistiter"]]],[11,"iter_mut","","Returns a mutable iterator over the list.",20,[[["self"]],["treaplistitermut"]]],[11,"new","","Constructs a new, empty `TreapMap<T, U>`.",21,[[],["self"]]],[11,"insert","","Inserts a key-value pair into the map. If the key already…",21,[[["u"],["self"],["t"]],["option"]]],[11,"remove","","Removes a key-value pair from the map. If the key exists…",21,[[["self"],["v"]],["option"]]],[11,"contains_key","","Checks if a key exists in the map.",21,[[["v"],["self"]],["bool"]]],[11,"get","","Returns an immutable reference to the value associated…",21,[[["v"],["self"]],[["u"],["option"]]]],[11,"get_mut","","Returns a mutable reference to the value associated with a…",21,[[["self"],["v"]],[["option"],["u"]]]],[11,"len","","Returns the number of elements in the map.",21,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the map is empty.",21,[[["self"]],["bool"]]],[11,"clear","","Clears the map, removing all values.",21,[[["self"]]]],[11,"floor","","Returns a key in the map that is less than or equal to a…",21,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the map that is greater than or equal to…",21,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the map. Returns `None` if the…",21,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the map. Returns `None` if the…",21,[[["self"]],[["t"],["option"]]]],[11,"split_off","","Splits the map and returns the right part of the map. If…",21,[[["self"],["v"],["bool"]],["self"]]],[11,"union","","Returns the union of two maps. If there is a key that is…",21,[[],["self"]]],[11,"intersection","","Returns the intersection of two maps. If there is a key…",21,[[],["self"]]],[11,"difference","","Returns the difference of `left` and `right`. The returned…",21,[[],["self"]]],[11,"symmetric_difference","","Returns the symmetric difference of `left` and `right`.…",21,[[],["self"]]],[11,"iter","","Returns an iterator over the map. The iterator will yield…",21,[[["self"]],["treapmapiter"]]],[11,"iter_mut","","Returns a mutable iterator over the map. The iterator will…",21,[[["self"]],["treapmapitermut"]]],[11,"new","","Constructs a new, empty `TreapSet<T>`",22,[[],["self"]]],[11,"insert","","Inserts a key into the set. If the key already exists in…",22,[[["self"],["t"]],["option"]]],[11,"remove","","Removes a key from the set. If the key exists in the set,…",22,[[["self"],["t"]],["option"]]],[11,"contains","","Checks if a key exists in the set.",22,[[["v"],["self"]],["bool"]]],[11,"len","","Returns the number of elements in the set.",22,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the set is empty.",22,[[["self"]],["bool"]]],[11,"clear","","Clears the set, removing all values.",22,[[["self"]]]],[11,"floor","","Returns a key in the set that is less than or equal to a…",22,[[["v"],["self"]],[["t"],["option"]]]],[11,"ceil","","Returns a key in the set that is greater than or equal to…",22,[[["v"],["self"]],[["t"],["option"]]]],[11,"min","","Returns the minimum key of the set. Returns `None` if the…",22,[[["self"]],[["t"],["option"]]]],[11,"max","","Returns the maximum key of the set. Returns `None` if the…",22,[[["self"]],[["t"],["option"]]]],[11,"split_off","","Splits the set and returns the right part of the set. If…",22,[[["self"],["t"],["bool"]],["self"]]],[11,"union","","Returns the union of two set. The `+` operator is…",22,[[],["self"]]],[11,"intersection","","Returns the intersection of two sets.",22,[[],["self"]]],[11,"difference","","Returns the difference of `left` and `right`. The `-`…",22,[[],["self"]]],[11,"symmetric_difference","","Returns the symmetric difference of `left` and `right`.…",22,[[],["self"]]],[11,"iter","","Returns an iterator over the set. The iterator will yield…",22,[[["self"]],["treapsetiter"]]],[11,"from","extended_collections::arena","",23,[[["t"]],["t"]]],[11,"into","","",23,[[],["u"]]],[11,"to_owned","","",23,[[["self"]],["t"]]],[11,"clone_into","","",23,[[["self"],["t"]]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"type_id","","",23,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"from","extended_collections::avl_tree","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"into_iter","","",1,[[],["i"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"into_iter","","",2,[[],["i"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"from","extended_collections::bp_tree","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"from","extended_collections::lsm_tree","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"from","extended_collections::lsm_tree::compaction","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"from","extended_collections::radix","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"into_iter","","",10,[[],["i"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"into_iter","","",11,[[],["i"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"from","extended_collections::red_black_tree","",12,[[["t"]],["t"]]],[11,"into","","",12,[[],["u"]]],[11,"into_iter","","",12,[[],["i"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"type_id","","",12,[[["self"]],["typeid"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"into_iter","","",13,[[],["i"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"from","extended_collections::skiplist","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"into_iter","","",14,[[],["i"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"into_iter","","",15,[[],["i"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"into_iter","","",16,[[],["i"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"from","extended_collections::splay_tree","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"into_iter","","",17,[[],["i"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"into_iter","","",18,[[],["i"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"from","extended_collections::sync","",19,[[["t"]],["t"]]],[11,"into","","",19,[[],["u"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"type_id","","",19,[[["self"]],["typeid"]]],[11,"from","extended_collections::treap","",20,[[["t"]],["t"]]],[11,"into","","",20,[[],["u"]]],[11,"into_iter","","",20,[[],["i"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"type_id","","",20,[[["self"]],["typeid"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[],["u"]]],[11,"into_iter","","",21,[[],["i"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"into","","",22,[[],["u"]]],[11,"into_iter","","",22,[[],["i"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"type_id","","",22,[[["self"]],["typeid"]]],[11,"get_path","extended_collections::lsm_tree::compaction","",6,[[["self"]],["path"]]],[11,"get_max_in_memory_size","","",6,[[["self"]],["u64"]]],[11,"get_and_increment_logical_time","","",6,[[["self"]],[["u64"],["result",["u64"]]]]],[11,"try_compact","","",6,[[["self"],["sstable"]],["result"]]],[11,"flush","","",6,[[["self"]],["result"]]],[11,"get","","",6,[[["self"],["v"]],[["option",["sstablevalue"]],["result",["option"]]]]],[11,"len_hint","","",6,[[["self"]],[["usize"],["result",["usize"]]]]],[11,"len","","",6,[[["self"]],[["usize"],["result",["usize"]]]]],[11,"is_empty","","",6,[[["self"]],[["result",["bool"]],["bool"]]]],[11,"clear","","",6,[[["self"]],["result"]]],[11,"min","","",6,[[["self"]],[["result",["option"]],["option"]]]],[11,"max","","",6,[[["self"]],[["result",["option"]],["option"]]]],[11,"iter","","",6,[[["self"]],[["result",["box"]],["box",["compactioniter"]]]]],[11,"get_path","","",7,[[["self"]],["path"]]],[11,"get_max_in_memory_size","","",7,[[["self"]],["u64"]]],[11,"get_and_increment_logical_time","","",7,[[["self"]],[["u64"],["result",["u64"]]]]],[11,"try_compact","","",7,[[["self"],["sstable"]],["result"]]],[11,"flush","","",7,[[["self"]],["result"]]],[11,"get","","",7,[[["self"],["v"]],[["option",["sstablevalue"]],["result",["option"]]]]],[11,"len_hint","","",7,[[["self"]],[["usize"],["result",["usize"]]]]],[11,"len","","",7,[[["self"]],[["usize"],["result",["usize"]]]]],[11,"is_empty","","",7,[[["self"]],[["result",["bool"]],["bool"]]]],[11,"clear","","",7,[[["self"]],["result"]]],[11,"min","","",7,[[["self"]],[["result",["option"]],["option"]]]],[11,"max","","",7,[[["self"]],[["result",["option"]],["option"]]]],[11,"iter","","",7,[[["self"]],[["result",["box"]],["box",["compactioniter"]]]]],[11,"drop","extended_collections::skiplist","",14,[[["self"]]]],[11,"drop","","",15,[[["self"]]]],[11,"from","extended_collections::bp_tree","",3,[[["error"]],["error"]]],[11,"from","","",3,[[["error"]],["error"]]],[11,"from","extended_collections::lsm_tree","",5,[[["error"]],["error"]]],[11,"from","","",5,[[["error"]],["error"]]],[11,"into_iter","extended_collections::avl_tree","",1,[[]]],[11,"into_iter","","",2,[[]]],[11,"into_iter","extended_collections::radix","",10,[[]]],[11,"into_iter","","",11,[[]]],[11,"into_iter","extended_collections::red_black_tree","",12,[[]]],[11,"into_iter","","",13,[[]]],[11,"into_iter","extended_collections::skiplist","",14,[[]]],[11,"into_iter","","",15,[[]]],[11,"into_iter","","",16,[[]]],[11,"into_iter","extended_collections::splay_tree","",17,[[]]],[11,"into_iter","","",18,[[]]],[11,"into_iter","extended_collections::treap","",20,[[]]],[11,"into_iter","","",21,[[]]],[11,"into_iter","","",22,[[]]],[11,"clone","extended_collections::arena","",23,[[["self"]],["entry"]]],[11,"default","extended_collections::avl_tree","",1,[[],["self"]]],[11,"default","","",2,[[],["self"]]],[11,"default","extended_collections::radix","",10,[[],["self"]]],[11,"default","","",11,[[],["self"]]],[11,"default","extended_collections::red_black_tree","",12,[[],["self"]]],[11,"default","","",13,[[],["self"]]],[11,"default","extended_collections::skiplist","",14,[[],["self"]]],[11,"default","","",15,[[],["self"]]],[11,"default","","",16,[[],["self"]]],[11,"default","extended_collections::splay_tree","",17,[[],["self"]]],[11,"default","","",18,[[],["self"]]],[11,"default","extended_collections::sync","",19,[[],["self"]]],[11,"default","extended_collections::treap","",20,[[],["self"]]],[11,"default","","",21,[[],["self"]]],[11,"default","","",22,[[],["self"]]],[11,"eq","extended_collections::arena","",23,[[["self"],["entry"]],["bool"]]],[11,"ne","","",23,[[["self"],["entry"]],["bool"]]],[11,"fmt","","",23,[[["formatter"],["self"]],["result"]]],[11,"fmt","extended_collections::bp_tree","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","extended_collections::lsm_tree","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","extended_collections::bp_tree","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","extended_collections::lsm_tree","",5,[[["formatter"],["self"]],["result"]]],[11,"sub","extended_collections::skiplist","",15,[[["skipmap"]],["skipmap"]]],[11,"sub","","",16,[[["skipset"]],["skipset"]]],[11,"sub","extended_collections::treap","",21,[[["treapmap"]],["treapmap"]]],[11,"sub","","",22,[[["treapset"]],["treapset"]]],[11,"add","extended_collections::skiplist","",14,[[["skiplist"]],["skiplist"]]],[11,"add","","",15,[[["skipmap"]],["skipmap"]]],[11,"add","","",16,[[["skipset"]],["skipset"]]],[11,"add","extended_collections::treap","",20,[[["treaplist"]],["treaplist"]]],[11,"add","","",21,[[["treapmap"]],["treapmap"]]],[11,"add","","",22,[[["treapset"]],["treapset"]]],[11,"index","extended_collections::arena","",0,[[["self"],["entry"]]]],[11,"index","extended_collections::avl_tree","",1,[[["v"],["self"]]]],[11,"index","extended_collections::radix","",10,[[["self"]]]],[11,"index","extended_collections::red_black_tree","",12,[[["v"],["self"]]]],[11,"index","extended_collections::skiplist","",14,[[["self"],["usize"]]]],[11,"index","","",15,[[["v"],["self"]]]],[11,"index","extended_collections::splay_tree","",17,[[["v"],["self"]]]],[11,"index","extended_collections::treap","",20,[[["self"],["usize"]]]],[11,"index","","",21,[[["v"],["self"]]]],[11,"index_mut","extended_collections::arena","",0,[[["self"],["entry"]]]],[11,"index_mut","extended_collections::avl_tree","",1,[[["self"],["v"]]]],[11,"index_mut","extended_collections::radix","",10,[[["self"]]]],[11,"index_mut","extended_collections::red_black_tree","",12,[[["self"],["v"]]]],[11,"index_mut","extended_collections::skiplist","",14,[[["self"],["usize"]]]],[11,"index_mut","","",15,[[["self"],["v"]]]],[11,"index_mut","extended_collections::splay_tree","",17,[[["self"],["v"]]]],[11,"index_mut","extended_collections::treap","",20,[[["self"],["usize"]]]],[11,"index_mut","","",21,[[["self"],["v"]]]],[11,"source","extended_collections::bp_tree","",3,[[["self"]],[["option",["error"]],["error"]]]],[11,"source","extended_collections::lsm_tree","",5,[[["self"]],[["option",["error"]],["error"]]]]],"p":[[3,"TypedArena"],[3,"AvlMap"],[3,"AvlSet"],[4,"Error"],[3,"BpMap"],[4,"Error"],[3,"LeveledStrategy"],[3,"SizeTieredStrategy"],[8,"CompactionStrategy"],[3,"LsmMap"],[3,"RadixMap"],[3,"RadixSet"],[3,"RedBlackMap"],[3,"RedBlackSet"],[3,"SkipList"],[3,"SkipMap"],[3,"SkipSet"],[3,"SplayMap"],[3,"SplaySet"],[3,"Stack"],[3,"TreapList"],[3,"TreapMap"],[3,"TreapSet"],[3,"Entry"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);